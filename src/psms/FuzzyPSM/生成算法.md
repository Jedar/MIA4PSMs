# FuzzyPSM的生成算法

## 1. FuzzyPSM简介

与传统的PCFG模型不同，FuzzyPSM没有使用`LUDS`的策略来衡量口令组成，而是使用`B`来代替口令模板。换句话说，在FuzzyPSM中一个模板片段关心的是它的长度而不是内部字符类型。
例如口令`p@ssword123`的概率表示为$P(p@ssword123)=P(S \to B_8B_3) * P(B_8 \to password) * P(B_3 \to 123) * P(a \to @)$。
此外，与PCFG不同的是，对于每个片段的概率，FuzzyPSM不是使用其直接的统计概率$P(B_3 \to 123)$，而是使用字典树转移概率$P(B_3 \to 123)=P(S \to 1) * P(S1 \to 2) * P(S12 \to 3)$。

## 2. 朴素Monte Carlo生成算法

```python
# 初始化
def preprocess():
    CumB = 0.0 
    for base in B:
        base.cum_prob = CumB = CumB + base.prob
    for node in Trie:
        Cum = sum([child.count for child in node.children]), CumProb = 0.0
        for child in node.children:
            child.cum_prob = CumProb = CumProb + child.count / Cum
            child.prob = child.count / Cum
# 字典树随机生成算法
def generate_segment(length):
    start_prob = 1
    segment = ""
    node = Trie.root
    while length > 0:
        r = sample([0, 1])
        nextNode = binarySearch(node.children, r)
        length -= 1
        segment += nextNode.character
        start_prob *= nextNode.prob
        node = nextNode
    return (segment, start_prob)
# 添加leet变换
def apply_leet(password, prob):
    for rule in leet_rules:
        r = sample([0, 1])
        if r < rule.prob:
            password <- rule.apply(password)
            prob *= rule.prob
    return (password, prob)
# 添加大小写变换
def apply_caption(password, prob):
    r = sample([0, 1])
    if r < caption.prob:
        password <- caption.apply(password)
        prob *= caption.prob
    return (password, prob)
# FuzzyPSM生成算法
def generate_password():
    r = sample([0,1])
    base <- binarySearch(B, r)
    password = ""
    prob = 1.0 
    for terminal in base:
        segment, _prob = generate_segment(terminal.length)
        segment, _prob = apply_caption(segment, _prob)
        segment, _prob = apply_leet(segment, _prob)
        password += segment
        prob *= _prob
    return (password, prob)

```
